"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-stickynode";
exports.ids = ["vendor-chunks/react-stickynode"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-stickynode/dist/es/Sticky.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-stickynode/dist/es/Sticky.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"(ssr)/./node_modules/core-js/modules/es.object.set-prototype-of.js\");\n/* harmony import */ var core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"(ssr)/./node_modules/core-js/modules/es.object.get-prototype-of.js\");\n/* harmony import */ var core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"(ssr)/./node_modules/core-js/modules/es.object.to-string.js\");\n/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"(ssr)/./node_modules/core-js/modules/es.reflect.construct.js\");\n/* harmony import */ var core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"(ssr)/./node_modules/core-js/modules/es.object.define-property.js\");\n/* harmony import */ var core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_define_property_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.symbol.js */ \"(ssr)/./node_modules/core-js/modules/es.symbol.js\");\n/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"(ssr)/./node_modules/core-js/modules/es.symbol.description.js\");\n/* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.symbol.iterator.js\");\n/* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.array.iterator.js\");\n/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.string.iterator.js\");\n/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"(ssr)/./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var subscribe_ui_event__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! subscribe-ui-event */ \"(ssr)/./node_modules/subscribe-ui-event/index.es.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! classnames */ \"(ssr)/./node_modules/classnames/index.js\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var shallowequal__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! shallowequal */ \"(ssr)/./node_modules/shallowequal/index.js\");\n/* harmony import */ var shallowequal__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(shallowequal__WEBPACK_IMPORTED_MODULE_14__);\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n\n // constants\n\nvar STATUS_ORIGINAL = 0; // The default status, locating at the original position.\n\nvar STATUS_RELEASED = 1; // The released status, locating at somewhere on document but not default one.\n\nvar STATUS_FIXED = 2; // The sticky status, locating fixed to the top or the bottom of screen.\n\nvar TRANSFORM_PROP = 'transform'; // global variable for all instances\n\nvar doc;\nvar docBody;\nvar docEl;\nvar canEnableTransforms = true; // Use transform by default, so no Sticky on lower-end browser when no Modernizr\n\nvar M;\nvar scrollDelta = 0;\nvar win;\nvar winHeight = -1;\n\nvar Sticky = /*#__PURE__*/function (_Component) {\n  _inherits(Sticky, _Component);\n\n  var _super = _createSuper(Sticky);\n\n  function Sticky(props, context) {\n    var _this;\n\n    _classCallCheck(this, Sticky);\n\n    _this = _super.call(this, props, context);\n    _this.handleResize = _this.handleResize.bind(_assertThisInitialized(_this));\n    _this.handleScroll = _this.handleScroll.bind(_assertThisInitialized(_this));\n    _this.handleScrollStart = _this.handleScrollStart.bind(_assertThisInitialized(_this));\n    _this.delta = 0;\n    _this.stickyTop = 0;\n    _this.stickyBottom = 0;\n    _this.frozen = false;\n    _this.skipNextScrollEvent = false;\n    _this.scrollTop = -1;\n    _this.bottomBoundaryTarget;\n    _this.topTarget;\n    _this.subscribers;\n    _this.state = {\n      top: 0,\n      // A top offset from viewport top where Sticky sticks to when scrolling up\n      bottom: 0,\n      // A bottom offset from viewport top where Sticky sticks to when scrolling down\n      width: 0,\n      // Sticky width\n      height: 0,\n      // Sticky height\n      x: 0,\n      // The original x of Sticky\n      y: 0,\n      // The original y of Sticky\n      topBoundary: 0,\n      // The top boundary on document\n      bottomBoundary: Infinity,\n      // The bottom boundary on document\n      status: STATUS_ORIGINAL,\n      // The Sticky status\n      pos: 0,\n      // Real y-axis offset for rendering position-fixed and position-relative\n      activated: false // once browser info is available after mounted, it becomes true to avoid checksum error\n\n    };\n    return _this;\n  }\n\n  _createClass(Sticky, [{\n    key: \"getTargetHeight\",\n    value: function getTargetHeight(target) {\n      return target && target.offsetHeight || 0;\n    }\n  }, {\n    key: \"getTopPosition\",\n    value: function getTopPosition(top) {\n      // a top argument can be provided to override reading from the props\n      top = top || this.props.top || 0;\n\n      if (typeof top === 'string') {\n        if (!this.topTarget) {\n          this.topTarget = doc.querySelector(top);\n        }\n\n        top = this.getTargetHeight(this.topTarget);\n      }\n\n      return top;\n    }\n  }, {\n    key: \"getTargetBottom\",\n    value: function getTargetBottom(target) {\n      if (!target) {\n        return -1;\n      }\n\n      var rect = target.getBoundingClientRect();\n      return this.scrollTop + rect.bottom;\n    }\n  }, {\n    key: \"getBottomBoundary\",\n    value: function getBottomBoundary(bottomBoundary) {\n      // a bottomBoundary can be provided to avoid reading from the props\n      var boundary = bottomBoundary || this.props.bottomBoundary; // TODO, bottomBoundary was an object, depricate it later.\n\n      if (_typeof(boundary) === 'object') {\n        boundary = boundary.value || boundary.target || 0;\n      }\n\n      if (typeof boundary === 'string') {\n        if (!this.bottomBoundaryTarget) {\n          this.bottomBoundaryTarget = doc.querySelector(boundary);\n        }\n\n        boundary = this.getTargetBottom(this.bottomBoundaryTarget);\n      }\n\n      return boundary && boundary > 0 ? boundary : Infinity;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.setState({\n        status: STATUS_ORIGINAL,\n        pos: 0\n      });\n    }\n  }, {\n    key: \"release\",\n    value: function release(pos) {\n      this.setState({\n        status: STATUS_RELEASED,\n        pos: pos - this.state.y\n      });\n    }\n  }, {\n    key: \"fix\",\n    value: function fix(pos) {\n      this.setState({\n        status: STATUS_FIXED,\n        pos: pos\n      });\n    }\n    /**\n     * Update the initial position, width, and height. It should update whenever children change.\n     * @param {Object} options optional top and bottomBoundary new values\n     */\n\n  }, {\n    key: \"updateInitialDimension\",\n    value: function updateInitialDimension(options) {\n      options = options || {};\n\n      if (!this.outerElement || !this.innerElement) {\n        return;\n      }\n\n      var outerRect = this.outerElement.getBoundingClientRect();\n      var innerRect = this.innerElement.getBoundingClientRect();\n      var width = outerRect.width || outerRect.right - outerRect.left;\n      var height = innerRect.height || innerRect.bottom - innerRect.top;\n      var outerY = outerRect.top + this.scrollTop;\n      this.setState({\n        top: this.getTopPosition(options.top),\n        bottom: Math.min(this.state.top + height, winHeight),\n        width: width,\n        height: height,\n        x: outerRect.left,\n        y: outerY,\n        bottomBoundary: this.getBottomBoundary(options.bottomBoundary),\n        topBoundary: outerY\n      });\n    }\n  }, {\n    key: \"handleResize\",\n    value: function handleResize(e, ae) {\n      if (this.props.shouldFreeze()) {\n        return;\n      }\n\n      winHeight = ae.resize.height;\n      this.updateInitialDimension();\n      this.update();\n    }\n  }, {\n    key: \"handleScrollStart\",\n    value: function handleScrollStart(e, ae) {\n      this.frozen = this.props.shouldFreeze();\n\n      if (this.frozen) {\n        return;\n      }\n\n      if (this.scrollTop === ae.scroll.top) {\n        // Scroll position hasn't changed,\n        // do nothing\n        this.skipNextScrollEvent = true;\n      } else {\n        this.scrollTop = ae.scroll.top;\n        this.updateInitialDimension();\n      }\n    }\n  }, {\n    key: \"handleScroll\",\n    value: function handleScroll(e, ae) {\n      // Scroll doesn't need to be handled\n      if (this.skipNextScrollEvent) {\n        this.skipNextScrollEvent = false;\n        return;\n      }\n\n      scrollDelta = ae.scroll.delta;\n      this.scrollTop = ae.scroll.top;\n      this.update();\n    }\n    /**\n     * Update Sticky position.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      var disabled = !this.props.enabled || this.state.bottomBoundary - this.state.topBoundary <= this.state.height || this.state.width === 0 && this.state.height === 0;\n\n      if (disabled) {\n        if (this.state.status !== STATUS_ORIGINAL) {\n          this.reset();\n        }\n\n        return;\n      }\n\n      var delta = scrollDelta; // \"top\" and \"bottom\" are the positions that this.state.top and this.state.bottom project\n      // on document from viewport.\n\n      var top = this.scrollTop + this.state.top;\n      var bottom = this.scrollTop + this.state.bottom; // There are 2 principles to make sure Sticky won't get wrong so much:\n      // 1. Reset Sticky to the original postion when \"top\" <= topBoundary\n      // 2. Release Sticky to the bottom boundary when \"bottom\" >= bottomBoundary\n\n      if (top <= this.state.topBoundary) {\n        // #1\n        this.reset();\n      } else if (bottom >= this.state.bottomBoundary) {\n        // #2\n        this.stickyBottom = this.state.bottomBoundary;\n        this.stickyTop = this.stickyBottom - this.state.height;\n        this.release(this.stickyTop);\n      } else {\n        if (this.state.height > winHeight - this.state.top) {\n          // In this case, Sticky is higher then viewport minus top offset\n          switch (this.state.status) {\n            case STATUS_ORIGINAL:\n              this.release(this.state.y);\n              this.stickyTop = this.state.y;\n              this.stickyBottom = this.stickyTop + this.state.height;\n            // Commentting out \"break\" is on purpose, because there is a chance to transit to FIXED\n            // from ORIGINAL when calling window.scrollTo().\n            // break;\n\n            case STATUS_RELEASED:\n              // If \"top\" and \"bottom\" are inbetween stickyTop and stickyBottom, then Sticky is in\n              // RELEASE status. Otherwise, it changes to FIXED status, and its bottom sticks to\n              // viewport bottom when scrolling down, or its top sticks to viewport top when scrolling up.\n              this.stickyBottom = this.stickyTop + this.state.height;\n\n              if (delta > 0 && bottom > this.stickyBottom) {\n                this.fix(this.state.bottom - this.state.height);\n              } else if (delta < 0 && top < this.stickyTop) {\n                this.fix(this.state.top);\n              }\n\n              break;\n\n            case STATUS_FIXED:\n              var toRelease = true;\n              var pos = this.state.pos;\n              var height = this.state.height; // In regular cases, when Sticky is in FIXED status,\n              // 1. it's top will stick to the screen top,\n              // 2. it's bottom will stick to the screen bottom,\n              // 3. if not the cases above, then it's height gets changed\n\n              if (delta > 0 && pos === this.state.top) {\n                // case 1, and scrolling down\n                this.stickyTop = top - delta;\n                this.stickyBottom = this.stickyTop + height;\n              } else if (delta < 0 && pos === this.state.bottom - height) {\n                // case 2, and scrolling up\n                this.stickyBottom = bottom - delta;\n                this.stickyTop = this.stickyBottom - height;\n              } else if (pos !== this.state.bottom - height && pos !== this.state.top) {\n                // case 3\n                // This case only happens when Sticky's bottom sticks to the screen bottom and\n                // its height gets changed. Sticky should be in RELEASE status and update its\n                // sticky bottom by calculating how much height it changed.\n                var deltaHeight = pos + height - this.state.bottom;\n                this.stickyBottom = bottom - delta + deltaHeight;\n                this.stickyTop = this.stickyBottom - height;\n              } else {\n                toRelease = false;\n              }\n\n              if (toRelease) {\n                this.release(this.stickyTop);\n              }\n\n              break;\n          }\n        } else {\n          // In this case, Sticky is shorter then viewport minus top offset\n          // and will always fix to the top offset of viewport\n          this.fix(this.state.top);\n        }\n      }\n\n      this.delta = delta;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      if (prevState.status !== this.state.status && this.props.onStateChange) {\n        this.props.onStateChange({\n          status: this.state.status\n        });\n      } // check if we are up-to-date, is triggered in case of scroll restoration\n\n\n      if (this.state.top !== prevState.top) {\n        this.updateInitialDimension();\n        this.update();\n      }\n\n      var arePropsChanged = !shallowequal__WEBPACK_IMPORTED_MODULE_14___default()(this.props, prevProps);\n\n      if (arePropsChanged) {\n        // if the props for enabling are toggled, then trigger the update or reset depending on the current props\n        if (prevProps.enabled !== this.props.enabled) {\n          if (this.props.enabled) {\n            this.setState({\n              activated: true\n            }, function () {\n              _this2.updateInitialDimension();\n\n              _this2.update();\n            });\n          } else {\n            this.setState({\n              activated: false\n            }, function () {\n              _this2.reset();\n            });\n          }\n        } // if the top or bottomBoundary props were changed, then trigger the update\n        else if (prevProps.top !== this.props.top || prevProps.bottomBoundary !== this.props.bottomBoundary) {\n          this.updateInitialDimension();\n          this.update();\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var subscribers = this.subscribers || [];\n\n      for (var i = subscribers.length - 1; i >= 0; i--) {\n        this.subscribers[i].unsubscribe();\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // Only initialize the globals if this is the first\n      // time this component type has been mounted\n      if (!win) {\n        win = window;\n        doc = document;\n        docEl = doc.documentElement;\n        docBody = doc.body;\n        winHeight = win.innerHeight || docEl.clientHeight;\n        M = window.Modernizr; // No Sticky on lower-end browser when no Modernizr\n\n        if (M && M.prefixed) {\n          canEnableTransforms = M.csstransforms3d;\n          TRANSFORM_PROP = M.prefixed('transform');\n        }\n      } // when mount, the scrollTop is not necessary on the top\n\n\n      this.scrollTop = docBody.scrollTop + docEl.scrollTop;\n\n      if (this.props.enabled) {\n        this.setState({\n          activated: true\n        });\n        this.updateInitialDimension();\n        this.update();\n      } // bind the listeners regardless if initially enabled - allows the component to toggle sticky functionality\n\n\n      this.subscribers = [(0,subscribe_ui_event__WEBPACK_IMPORTED_MODULE_12__.subscribe)('scrollStart', this.handleScrollStart.bind(this), {\n        useRAF: true\n      }), (0,subscribe_ui_event__WEBPACK_IMPORTED_MODULE_12__.subscribe)('scroll', this.handleScroll.bind(this), {\n        useRAF: true,\n        enableScrollInfo: true\n      }), (0,subscribe_ui_event__WEBPACK_IMPORTED_MODULE_12__.subscribe)('resize', this.handleResize.bind(this), {\n        enableResizeInfo: true\n      })];\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(style, pos) {\n      var enableTransforms = canEnableTransforms && this.props.enableTransforms;\n\n      if (enableTransforms && this.state.activated) {\n        style[TRANSFORM_PROP] = 'translate3d(0,' + Math.round(pos) + 'px,0)';\n      } else {\n        style.top = pos + 'px';\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      return !this.props.shouldFreeze() && !(shallowequal__WEBPACK_IMPORTED_MODULE_14___default()(this.props, nextProps) && shallowequal__WEBPACK_IMPORTED_MODULE_14___default()(this.state, nextState));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _classNames,\n          _this3 = this;\n\n      // TODO, \"overflow: auto\" prevents collapse, need a good way to get children height\n      var innerStyle = {\n        position: this.state.status === STATUS_FIXED ? 'fixed' : 'relative',\n        top: this.state.status === STATUS_FIXED ? '0px' : '',\n        zIndex: this.props.innerZ\n      };\n      var outerStyle = {}; // always use translate3d to enhance the performance\n\n      this.translate(innerStyle, this.state.pos);\n\n      if (this.state.status !== STATUS_ORIGINAL) {\n        innerStyle.width = this.state.width + 'px';\n        outerStyle.height = this.state.height + 'px';\n      }\n\n      var outerClasses = classnames__WEBPACK_IMPORTED_MODULE_13___default()('sticky-outer-wrapper', this.props.className, (_classNames = {}, _defineProperty(_classNames, this.props.activeClass, this.state.status === STATUS_FIXED), _defineProperty(_classNames, this.props.releasedClass, this.state.status === STATUS_RELEASED), _classNames));\n      var innerClasses = classnames__WEBPACK_IMPORTED_MODULE_13___default()('sticky-inner-wrapper', this.props.innerClass, _defineProperty({}, this.props.innerActiveClass, this.state.status === STATUS_FIXED));\n      var children = this.props.children;\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_11___default().createElement(\"div\", {\n        ref: function ref(outer) {\n          _this3.outerElement = outer;\n        },\n        className: outerClasses,\n        style: outerStyle\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_11___default().createElement(\"div\", {\n        ref: function ref(inner) {\n          _this3.innerElement = inner;\n        },\n        className: innerClasses,\n        style: innerStyle\n      }, typeof children === 'function' ? children({\n        status: this.state.status\n      }) : children));\n    }\n  }]);\n\n  return Sticky;\n}(react__WEBPACK_IMPORTED_MODULE_11__.Component);\n\nSticky.displayName = 'Sticky';\nSticky.defaultProps = {\n  shouldFreeze: function shouldFreeze() {\n    return false;\n  },\n  enabled: true,\n  top: 0,\n  bottomBoundary: 0,\n  enableTransforms: true,\n  activeClass: 'active',\n  releasedClass: 'released',\n  onStateChange: null,\n  innerClass: '',\n  innerActiveClass: ''\n};\n/**\n * @param {Bool} enabled A switch to enable or disable Sticky.\n * @param {String/Number} top A top offset px for Sticky. Could be a selector representing a node\n *        whose height should serve as the top offset.\n * @param {String/Number} bottomBoundary A bottom boundary px on document where Sticky will stop.\n *        Could be a selector representing a node whose bottom should serve as the bottom boudary.\n */\n\nSticky.propTypes = {\n  enabled: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n  top: prop_types__WEBPACK_IMPORTED_MODULE_15___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_15___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_15___default().number)]),\n  bottomBoundary: prop_types__WEBPACK_IMPORTED_MODULE_15___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_15___default().object), // TODO, may remove\n  (prop_types__WEBPACK_IMPORTED_MODULE_15___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_15___default().number)]),\n  enableTransforms: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().bool),\n  activeClass: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().string),\n  releasedClass: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().string),\n  innerClass: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().string),\n  innerActiveClass: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().string),\n  className: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().string),\n  onStateChange: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().func),\n  shouldFreeze: (prop_types__WEBPACK_IMPORTED_MODULE_15___default().func),\n  innerZ: prop_types__WEBPACK_IMPORTED_MODULE_15___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_15___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_15___default().number)])\n};\nSticky.STATUS_ORIGINAL = STATUS_ORIGINAL;\nSticky.STATUS_RELEASED = STATUS_RELEASED;\nSticky.STATUS_FIXED = STATUS_FIXED;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sticky);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc3RpY2t5bm9kZS9kaXN0L2VzL1N0aWNreS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRTBDO0FBQ0E7QUFDUDtBQUNDO0FBQ0s7QUFDaEI7QUFDWTtBQUNIO0FBQ0Q7QUFDQztBQUNVOztBQUV6RCw0Q0FBNEMsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjs7QUFFcE0sd0JBQXdCLDJCQUEyQixzR0FBc0cscUJBQXFCLG1CQUFtQiw4SEFBOEg7O0FBRS9ULGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7O0FBRXhRLDJDQUEyQywrREFBK0QsNkVBQTZFLHlFQUF5RSxlQUFlLHVEQUF1RCxHQUFHLCtDQUErQyxpQkFBaUIsR0FBRzs7QUFFNVksaUNBQWlDLDBHQUEwRyxpQkFBaUIsYUFBYTs7QUFFekssaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDOztBQUVwWCxrREFBa0QsMEVBQTBFLGVBQWUsNEJBQTRCLG1GQUFtRjs7QUFFMVAsd0NBQXdDLHVCQUF1Qix5RkFBeUY7O0FBRXhKLHVDQUF1Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFeFQsOEJBQThCLHVHQUF1RyxtREFBbUQ7O0FBRS9JO0FBQ047QUFDWTtBQUNYO0FBQ0ksQ0FBQzs7QUFFekMseUJBQXlCOztBQUV6Qix5QkFBeUI7O0FBRXpCLHNCQUFzQjs7QUFFdEIsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsb0RBQVk7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7OztBQUdSLDBCQUEwQiw4REFBUztBQUNuQztBQUNBLE9BQU8sR0FBRyw4REFBUztBQUNuQjtBQUNBO0FBQ0EsT0FBTyxHQUFHLDhEQUFTO0FBQ25CO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkNBQTZDLG9EQUFZLDJCQUEyQixvREFBWTtBQUNoRztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixrREFBVSxnRUFBZ0U7QUFDbkcseUJBQXlCLGtEQUFVLGtFQUFrRTtBQUNyRztBQUNBLDBCQUEwQiwyREFBbUI7QUFDN0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyxlQUFlLDJEQUFtQjtBQUN6QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxDQUFDLDZDQUFTOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxlQUFlO0FBQzFCO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHlEQUFjO0FBQ3pCLE9BQU8sNERBQW1CLEVBQUUsMkRBQWdCLEVBQUUsMkRBQWdCO0FBQzlELGtCQUFrQiw0REFBbUIsRUFBRSwyREFBZ0I7QUFDdkQsRUFBRSwyREFBZ0IsRUFBRSwyREFBZ0I7QUFDcEMsb0JBQW9CLHlEQUFjO0FBQ2xDLGVBQWUsMkRBQWdCO0FBQy9CLGlCQUFpQiwyREFBZ0I7QUFDakMsY0FBYywyREFBZ0I7QUFDOUIsb0JBQW9CLDJEQUFnQjtBQUNwQyxhQUFhLDJEQUFnQjtBQUM3QixpQkFBaUIseURBQWM7QUFDL0IsZ0JBQWdCLHlEQUFjO0FBQzlCLFVBQVUsNERBQW1CLEVBQUUsMkRBQWdCLEVBQUUsMkRBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL25lY3hpc19zdGF0aWNfd2ViLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXN0aWNreW5vZGUvZGlzdC9lcy9TdGlja3kuanM/OWJkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBcImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXCI7XG5pbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0LmpzXCI7XG5pbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qc1wiO1xuaW1wb3J0IFwiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXCI7XG5pbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXCI7XG5pbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qc1wiO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBzdWJzY3JpYmUgfSBmcm9tICdzdWJzY3JpYmUtdWktZXZlbnQnO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJ3NoYWxsb3dlcXVhbCc7IC8vIGNvbnN0YW50c1xuXG52YXIgU1RBVFVTX09SSUdJTkFMID0gMDsgLy8gVGhlIGRlZmF1bHQgc3RhdHVzLCBsb2NhdGluZyBhdCB0aGUgb3JpZ2luYWwgcG9zaXRpb24uXG5cbnZhciBTVEFUVVNfUkVMRUFTRUQgPSAxOyAvLyBUaGUgcmVsZWFzZWQgc3RhdHVzLCBsb2NhdGluZyBhdCBzb21ld2hlcmUgb24gZG9jdW1lbnQgYnV0IG5vdCBkZWZhdWx0IG9uZS5cblxudmFyIFNUQVRVU19GSVhFRCA9IDI7IC8vIFRoZSBzdGlja3kgc3RhdHVzLCBsb2NhdGluZyBmaXhlZCB0byB0aGUgdG9wIG9yIHRoZSBib3R0b20gb2Ygc2NyZWVuLlxuXG52YXIgVFJBTlNGT1JNX1BST1AgPSAndHJhbnNmb3JtJzsgLy8gZ2xvYmFsIHZhcmlhYmxlIGZvciBhbGwgaW5zdGFuY2VzXG5cbnZhciBkb2M7XG52YXIgZG9jQm9keTtcbnZhciBkb2NFbDtcbnZhciBjYW5FbmFibGVUcmFuc2Zvcm1zID0gdHJ1ZTsgLy8gVXNlIHRyYW5zZm9ybSBieSBkZWZhdWx0LCBzbyBubyBTdGlja3kgb24gbG93ZXItZW5kIGJyb3dzZXIgd2hlbiBubyBNb2Rlcm5penJcblxudmFyIE07XG52YXIgc2Nyb2xsRGVsdGEgPSAwO1xudmFyIHdpbjtcbnZhciB3aW5IZWlnaHQgPSAtMTtcblxudmFyIFN0aWNreSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3RpY2t5LCBfQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFN0aWNreSk7XG5cbiAgZnVuY3Rpb24gU3RpY2t5KHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0aWNreSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICBfdGhpcy5oYW5kbGVSZXNpemUgPSBfdGhpcy5oYW5kbGVSZXNpemUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlU2Nyb2xsID0gX3RoaXMuaGFuZGxlU2Nyb2xsLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZVNjcm9sbFN0YXJ0ID0gX3RoaXMuaGFuZGxlU2Nyb2xsU3RhcnQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuZGVsdGEgPSAwO1xuICAgIF90aGlzLnN0aWNreVRvcCA9IDA7XG4gICAgX3RoaXMuc3RpY2t5Qm90dG9tID0gMDtcbiAgICBfdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICBfdGhpcy5za2lwTmV4dFNjcm9sbEV2ZW50ID0gZmFsc2U7XG4gICAgX3RoaXMuc2Nyb2xsVG9wID0gLTE7XG4gICAgX3RoaXMuYm90dG9tQm91bmRhcnlUYXJnZXQ7XG4gICAgX3RoaXMudG9wVGFyZ2V0O1xuICAgIF90aGlzLnN1YnNjcmliZXJzO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgLy8gQSB0b3Agb2Zmc2V0IGZyb20gdmlld3BvcnQgdG9wIHdoZXJlIFN0aWNreSBzdGlja3MgdG8gd2hlbiBzY3JvbGxpbmcgdXBcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIC8vIEEgYm90dG9tIG9mZnNldCBmcm9tIHZpZXdwb3J0IHRvcCB3aGVyZSBTdGlja3kgc3RpY2tzIHRvIHdoZW4gc2Nyb2xsaW5nIGRvd25cbiAgICAgIHdpZHRoOiAwLFxuICAgICAgLy8gU3RpY2t5IHdpZHRoXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICAvLyBTdGlja3kgaGVpZ2h0XG4gICAgICB4OiAwLFxuICAgICAgLy8gVGhlIG9yaWdpbmFsIHggb2YgU3RpY2t5XG4gICAgICB5OiAwLFxuICAgICAgLy8gVGhlIG9yaWdpbmFsIHkgb2YgU3RpY2t5XG4gICAgICB0b3BCb3VuZGFyeTogMCxcbiAgICAgIC8vIFRoZSB0b3AgYm91bmRhcnkgb24gZG9jdW1lbnRcbiAgICAgIGJvdHRvbUJvdW5kYXJ5OiBJbmZpbml0eSxcbiAgICAgIC8vIFRoZSBib3R0b20gYm91bmRhcnkgb24gZG9jdW1lbnRcbiAgICAgIHN0YXR1czogU1RBVFVTX09SSUdJTkFMLFxuICAgICAgLy8gVGhlIFN0aWNreSBzdGF0dXNcbiAgICAgIHBvczogMCxcbiAgICAgIC8vIFJlYWwgeS1heGlzIG9mZnNldCBmb3IgcmVuZGVyaW5nIHBvc2l0aW9uLWZpeGVkIGFuZCBwb3NpdGlvbi1yZWxhdGl2ZVxuICAgICAgYWN0aXZhdGVkOiBmYWxzZSAvLyBvbmNlIGJyb3dzZXIgaW5mbyBpcyBhdmFpbGFibGUgYWZ0ZXIgbW91bnRlZCwgaXQgYmVjb21lcyB0cnVlIHRvIGF2b2lkIGNoZWNrc3VtIGVycm9yXG5cbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdGlja3ksIFt7XG4gICAga2V5OiBcImdldFRhcmdldEhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUYXJnZXRIZWlnaHQodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldC5vZmZzZXRIZWlnaHQgfHwgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VG9wUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG9wUG9zaXRpb24odG9wKSB7XG4gICAgICAvLyBhIHRvcCBhcmd1bWVudCBjYW4gYmUgcHJvdmlkZWQgdG8gb3ZlcnJpZGUgcmVhZGluZyBmcm9tIHRoZSBwcm9wc1xuICAgICAgdG9wID0gdG9wIHx8IHRoaXMucHJvcHMudG9wIHx8IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgdG9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIXRoaXMudG9wVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy50b3BUYXJnZXQgPSBkb2MucXVlcnlTZWxlY3Rvcih0b3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9wID0gdGhpcy5nZXRUYXJnZXRIZWlnaHQodGhpcy50b3BUYXJnZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9wO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUYXJnZXRCb3R0b21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFyZ2V0Qm90dG9tKHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvcCArIHJlY3QuYm90dG9tO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3R0b21Cb3VuZGFyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3R0b21Cb3VuZGFyeShib3R0b21Cb3VuZGFyeSkge1xuICAgICAgLy8gYSBib3R0b21Cb3VuZGFyeSBjYW4gYmUgcHJvdmlkZWQgdG8gYXZvaWQgcmVhZGluZyBmcm9tIHRoZSBwcm9wc1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gYm90dG9tQm91bmRhcnkgfHwgdGhpcy5wcm9wcy5ib3R0b21Cb3VuZGFyeTsgLy8gVE9ETywgYm90dG9tQm91bmRhcnkgd2FzIGFuIG9iamVjdCwgZGVwcmljYXRlIGl0IGxhdGVyLlxuXG4gICAgICBpZiAoX3R5cGVvZihib3VuZGFyeSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGJvdW5kYXJ5ID0gYm91bmRhcnkudmFsdWUgfHwgYm91bmRhcnkudGFyZ2V0IHx8IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYm91bmRhcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghdGhpcy5ib3R0b21Cb3VuZGFyeVRhcmdldCkge1xuICAgICAgICAgIHRoaXMuYm90dG9tQm91bmRhcnlUYXJnZXQgPSBkb2MucXVlcnlTZWxlY3Rvcihib3VuZGFyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBib3VuZGFyeSA9IHRoaXMuZ2V0VGFyZ2V0Qm90dG9tKHRoaXMuYm90dG9tQm91bmRhcnlUYXJnZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm91bmRhcnkgJiYgYm91bmRhcnkgPiAwID8gYm91bmRhcnkgOiBJbmZpbml0eTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBTVEFUVVNfT1JJR0lOQUwsXG4gICAgICAgIHBvczogMFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbGVhc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZShwb3MpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IFNUQVRVU19SRUxFQVNFRCxcbiAgICAgICAgcG9zOiBwb3MgLSB0aGlzLnN0YXRlLnlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4KHBvcykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogU1RBVFVTX0ZJWEVELFxuICAgICAgICBwb3M6IHBvc1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgaW5pdGlhbCBwb3NpdGlvbiwgd2lkdGgsIGFuZCBoZWlnaHQuIEl0IHNob3VsZCB1cGRhdGUgd2hlbmV2ZXIgY2hpbGRyZW4gY2hhbmdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbmFsIHRvcCBhbmQgYm90dG9tQm91bmRhcnkgbmV3IHZhbHVlc1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlSW5pdGlhbERpbWVuc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVJbml0aWFsRGltZW5zaW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICBpZiAoIXRoaXMub3V0ZXJFbGVtZW50IHx8ICF0aGlzLmlubmVyRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRlclJlY3QgPSB0aGlzLm91dGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBpbm5lclJlY3QgPSB0aGlzLmlubmVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB3aWR0aCA9IG91dGVyUmVjdC53aWR0aCB8fCBvdXRlclJlY3QucmlnaHQgLSBvdXRlclJlY3QubGVmdDtcbiAgICAgIHZhciBoZWlnaHQgPSBpbm5lclJlY3QuaGVpZ2h0IHx8IGlubmVyUmVjdC5ib3R0b20gLSBpbm5lclJlY3QudG9wO1xuICAgICAgdmFyIG91dGVyWSA9IG91dGVyUmVjdC50b3AgKyB0aGlzLnNjcm9sbFRvcDtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICB0b3A6IHRoaXMuZ2V0VG9wUG9zaXRpb24ob3B0aW9ucy50b3ApLFxuICAgICAgICBib3R0b206IE1hdGgubWluKHRoaXMuc3RhdGUudG9wICsgaGVpZ2h0LCB3aW5IZWlnaHQpLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICB4OiBvdXRlclJlY3QubGVmdCxcbiAgICAgICAgeTogb3V0ZXJZLFxuICAgICAgICBib3R0b21Cb3VuZGFyeTogdGhpcy5nZXRCb3R0b21Cb3VuZGFyeShvcHRpb25zLmJvdHRvbUJvdW5kYXJ5KSxcbiAgICAgICAgdG9wQm91bmRhcnk6IG91dGVyWVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVSZXNpemUoZSwgYWUpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnNob3VsZEZyZWV6ZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2luSGVpZ2h0ID0gYWUucmVzaXplLmhlaWdodDtcbiAgICAgIHRoaXMudXBkYXRlSW5pdGlhbERpbWVuc2lvbigpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlU2Nyb2xsU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlU2Nyb2xsU3RhcnQoZSwgYWUpIHtcbiAgICAgIHRoaXMuZnJvemVuID0gdGhpcy5wcm9wcy5zaG91bGRGcmVlemUoKTtcblxuICAgICAgaWYgKHRoaXMuZnJvemVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2Nyb2xsVG9wID09PSBhZS5zY3JvbGwudG9wKSB7XG4gICAgICAgIC8vIFNjcm9sbCBwb3NpdGlvbiBoYXNuJ3QgY2hhbmdlZCxcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB0aGlzLnNraXBOZXh0U2Nyb2xsRXZlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBhZS5zY3JvbGwudG9wO1xuICAgICAgICB0aGlzLnVwZGF0ZUluaXRpYWxEaW1lbnNpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlU2Nyb2xsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVNjcm9sbChlLCBhZSkge1xuICAgICAgLy8gU2Nyb2xsIGRvZXNuJ3QgbmVlZCB0byBiZSBoYW5kbGVkXG4gICAgICBpZiAodGhpcy5za2lwTmV4dFNjcm9sbEV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2tpcE5leHRTY3JvbGxFdmVudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNjcm9sbERlbHRhID0gYWUuc2Nyb2xsLmRlbHRhO1xuICAgICAgdGhpcy5zY3JvbGxUb3AgPSBhZS5zY3JvbGwudG9wO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIFN0aWNreSBwb3NpdGlvbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgZGlzYWJsZWQgPSAhdGhpcy5wcm9wcy5lbmFibGVkIHx8IHRoaXMuc3RhdGUuYm90dG9tQm91bmRhcnkgLSB0aGlzLnN0YXRlLnRvcEJvdW5kYXJ5IDw9IHRoaXMuc3RhdGUuaGVpZ2h0IHx8IHRoaXMuc3RhdGUud2lkdGggPT09IDAgJiYgdGhpcy5zdGF0ZS5oZWlnaHQgPT09IDA7XG5cbiAgICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgIT09IFNUQVRVU19PUklHSU5BTCkge1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gc2Nyb2xsRGVsdGE7IC8vIFwidG9wXCIgYW5kIFwiYm90dG9tXCIgYXJlIHRoZSBwb3NpdGlvbnMgdGhhdCB0aGlzLnN0YXRlLnRvcCBhbmQgdGhpcy5zdGF0ZS5ib3R0b20gcHJvamVjdFxuICAgICAgLy8gb24gZG9jdW1lbnQgZnJvbSB2aWV3cG9ydC5cblxuICAgICAgdmFyIHRvcCA9IHRoaXMuc2Nyb2xsVG9wICsgdGhpcy5zdGF0ZS50b3A7XG4gICAgICB2YXIgYm90dG9tID0gdGhpcy5zY3JvbGxUb3AgKyB0aGlzLnN0YXRlLmJvdHRvbTsgLy8gVGhlcmUgYXJlIDIgcHJpbmNpcGxlcyB0byBtYWtlIHN1cmUgU3RpY2t5IHdvbid0IGdldCB3cm9uZyBzbyBtdWNoOlxuICAgICAgLy8gMS4gUmVzZXQgU3RpY2t5IHRvIHRoZSBvcmlnaW5hbCBwb3N0aW9uIHdoZW4gXCJ0b3BcIiA8PSB0b3BCb3VuZGFyeVxuICAgICAgLy8gMi4gUmVsZWFzZSBTdGlja3kgdG8gdGhlIGJvdHRvbSBib3VuZGFyeSB3aGVuIFwiYm90dG9tXCIgPj0gYm90dG9tQm91bmRhcnlcblxuICAgICAgaWYgKHRvcCA8PSB0aGlzLnN0YXRlLnRvcEJvdW5kYXJ5KSB7XG4gICAgICAgIC8vICMxXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoYm90dG9tID49IHRoaXMuc3RhdGUuYm90dG9tQm91bmRhcnkpIHtcbiAgICAgICAgLy8gIzJcbiAgICAgICAgdGhpcy5zdGlja3lCb3R0b20gPSB0aGlzLnN0YXRlLmJvdHRvbUJvdW5kYXJ5O1xuICAgICAgICB0aGlzLnN0aWNreVRvcCA9IHRoaXMuc3RpY2t5Qm90dG9tIC0gdGhpcy5zdGF0ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMucmVsZWFzZSh0aGlzLnN0aWNreVRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5oZWlnaHQgPiB3aW5IZWlnaHQgLSB0aGlzLnN0YXRlLnRvcCkge1xuICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgU3RpY2t5IGlzIGhpZ2hlciB0aGVuIHZpZXdwb3J0IG1pbnVzIHRvcCBvZmZzZXRcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFNUQVRVU19PUklHSU5BTDpcbiAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlKHRoaXMuc3RhdGUueSk7XG4gICAgICAgICAgICAgIHRoaXMuc3RpY2t5VG9wID0gdGhpcy5zdGF0ZS55O1xuICAgICAgICAgICAgICB0aGlzLnN0aWNreUJvdHRvbSA9IHRoaXMuc3RpY2t5VG9wICsgdGhpcy5zdGF0ZS5oZWlnaHQ7XG4gICAgICAgICAgICAvLyBDb21tZW50dGluZyBvdXQgXCJicmVha1wiIGlzIG9uIHB1cnBvc2UsIGJlY2F1c2UgdGhlcmUgaXMgYSBjaGFuY2UgdG8gdHJhbnNpdCB0byBGSVhFRFxuICAgICAgICAgICAgLy8gZnJvbSBPUklHSU5BTCB3aGVuIGNhbGxpbmcgd2luZG93LnNjcm9sbFRvKCkuXG4gICAgICAgICAgICAvLyBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTVEFUVVNfUkVMRUFTRUQ6XG4gICAgICAgICAgICAgIC8vIElmIFwidG9wXCIgYW5kIFwiYm90dG9tXCIgYXJlIGluYmV0d2VlbiBzdGlja3lUb3AgYW5kIHN0aWNreUJvdHRvbSwgdGhlbiBTdGlja3kgaXMgaW5cbiAgICAgICAgICAgICAgLy8gUkVMRUFTRSBzdGF0dXMuIE90aGVyd2lzZSwgaXQgY2hhbmdlcyB0byBGSVhFRCBzdGF0dXMsIGFuZCBpdHMgYm90dG9tIHN0aWNrcyB0b1xuICAgICAgICAgICAgICAvLyB2aWV3cG9ydCBib3R0b20gd2hlbiBzY3JvbGxpbmcgZG93biwgb3IgaXRzIHRvcCBzdGlja3MgdG8gdmlld3BvcnQgdG9wIHdoZW4gc2Nyb2xsaW5nIHVwLlxuICAgICAgICAgICAgICB0aGlzLnN0aWNreUJvdHRvbSA9IHRoaXMuc3RpY2t5VG9wICsgdGhpcy5zdGF0ZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgaWYgKGRlbHRhID4gMCAmJiBib3R0b20gPiB0aGlzLnN0aWNreUJvdHRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZml4KHRoaXMuc3RhdGUuYm90dG9tIC0gdGhpcy5zdGF0ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlbHRhIDwgMCAmJiB0b3AgPCB0aGlzLnN0aWNreVRvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZml4KHRoaXMuc3RhdGUudG9wKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNUQVRVU19GSVhFRDpcbiAgICAgICAgICAgICAgdmFyIHRvUmVsZWFzZSA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuc3RhdGUuaGVpZ2h0OyAvLyBJbiByZWd1bGFyIGNhc2VzLCB3aGVuIFN0aWNreSBpcyBpbiBGSVhFRCBzdGF0dXMsXG4gICAgICAgICAgICAgIC8vIDEuIGl0J3MgdG9wIHdpbGwgc3RpY2sgdG8gdGhlIHNjcmVlbiB0b3AsXG4gICAgICAgICAgICAgIC8vIDIuIGl0J3MgYm90dG9tIHdpbGwgc3RpY2sgdG8gdGhlIHNjcmVlbiBib3R0b20sXG4gICAgICAgICAgICAgIC8vIDMuIGlmIG5vdCB0aGUgY2FzZXMgYWJvdmUsIHRoZW4gaXQncyBoZWlnaHQgZ2V0cyBjaGFuZ2VkXG5cbiAgICAgICAgICAgICAgaWYgKGRlbHRhID4gMCAmJiBwb3MgPT09IHRoaXMuc3RhdGUudG9wKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSAxLCBhbmQgc2Nyb2xsaW5nIGRvd25cbiAgICAgICAgICAgICAgICB0aGlzLnN0aWNreVRvcCA9IHRvcCAtIGRlbHRhO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RpY2t5Qm90dG9tID0gdGhpcy5zdGlja3lUb3AgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPCAwICYmIHBvcyA9PT0gdGhpcy5zdGF0ZS5ib3R0b20gLSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBjYXNlIDIsIGFuZCBzY3JvbGxpbmcgdXBcbiAgICAgICAgICAgICAgICB0aGlzLnN0aWNreUJvdHRvbSA9IGJvdHRvbSAtIGRlbHRhO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RpY2t5VG9wID0gdGhpcy5zdGlja3lCb3R0b20gLSBoZWlnaHQ7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zICE9PSB0aGlzLnN0YXRlLmJvdHRvbSAtIGhlaWdodCAmJiBwb3MgIT09IHRoaXMuc3RhdGUudG9wKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSAzXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYXNlIG9ubHkgaGFwcGVucyB3aGVuIFN0aWNreSdzIGJvdHRvbSBzdGlja3MgdG8gdGhlIHNjcmVlbiBib3R0b20gYW5kXG4gICAgICAgICAgICAgICAgLy8gaXRzIGhlaWdodCBnZXRzIGNoYW5nZWQuIFN0aWNreSBzaG91bGQgYmUgaW4gUkVMRUFTRSBzdGF0dXMgYW5kIHVwZGF0ZSBpdHNcbiAgICAgICAgICAgICAgICAvLyBzdGlja3kgYm90dG9tIGJ5IGNhbGN1bGF0aW5nIGhvdyBtdWNoIGhlaWdodCBpdCBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgIHZhciBkZWx0YUhlaWdodCA9IHBvcyArIGhlaWdodCAtIHRoaXMuc3RhdGUuYm90dG9tO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RpY2t5Qm90dG9tID0gYm90dG9tIC0gZGVsdGEgKyBkZWx0YUhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0aWNreVRvcCA9IHRoaXMuc3RpY2t5Qm90dG9tIC0gaGVpZ2h0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvUmVsZWFzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRvUmVsZWFzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVsZWFzZSh0aGlzLnN0aWNreVRvcCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBTdGlja3kgaXMgc2hvcnRlciB0aGVuIHZpZXdwb3J0IG1pbnVzIHRvcCBvZmZzZXRcbiAgICAgICAgICAvLyBhbmQgd2lsbCBhbHdheXMgZml4IHRvIHRoZSB0b3Agb2Zmc2V0IG9mIHZpZXdwb3J0XG4gICAgICAgICAgdGhpcy5maXgodGhpcy5zdGF0ZS50b3ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVsdGEgPSBkZWx0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUuc3RhdHVzICE9PSB0aGlzLnN0YXRlLnN0YXR1cyAmJiB0aGlzLnByb3BzLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblN0YXRlQ2hhbmdlKHtcbiAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdGUuc3RhdHVzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBjaGVjayBpZiB3ZSBhcmUgdXAtdG8tZGF0ZSwgaXMgdHJpZ2dlcmVkIGluIGNhc2Ugb2Ygc2Nyb2xsIHJlc3RvcmF0aW9uXG5cblxuICAgICAgaWYgKHRoaXMuc3RhdGUudG9wICE9PSBwcmV2U3RhdGUudG9wKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSW5pdGlhbERpbWVuc2lvbigpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJlUHJvcHNDaGFuZ2VkID0gIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBwcmV2UHJvcHMpO1xuXG4gICAgICBpZiAoYXJlUHJvcHNDaGFuZ2VkKSB7XG4gICAgICAgIC8vIGlmIHRoZSBwcm9wcyBmb3IgZW5hYmxpbmcgYXJlIHRvZ2dsZWQsIHRoZW4gdHJpZ2dlciB0aGUgdXBkYXRlIG9yIHJlc2V0IGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBwcm9wc1xuICAgICAgICBpZiAocHJldlByb3BzLmVuYWJsZWQgIT09IHRoaXMucHJvcHMuZW5hYmxlZCkge1xuICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICBhY3RpdmF0ZWQ6IHRydWVcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLnVwZGF0ZUluaXRpYWxEaW1lbnNpb24oKTtcblxuICAgICAgICAgICAgICBfdGhpczIudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIGFjdGl2YXRlZDogZmFsc2VcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLnJlc2V0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgdGhlIHRvcCBvciBib3R0b21Cb3VuZGFyeSBwcm9wcyB3ZXJlIGNoYW5nZWQsIHRoZW4gdHJpZ2dlciB0aGUgdXBkYXRlXG4gICAgICAgIGVsc2UgaWYgKHByZXZQcm9wcy50b3AgIT09IHRoaXMucHJvcHMudG9wIHx8IHByZXZQcm9wcy5ib3R0b21Cb3VuZGFyeSAhPT0gdGhpcy5wcm9wcy5ib3R0b21Cb3VuZGFyeSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlSW5pdGlhbERpbWVuc2lvbigpO1xuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSB0aGlzLnN1YnNjcmliZXJzIHx8IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gc3Vic2NyaWJlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyc1tpXS51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRNb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIC8vIE9ubHkgaW5pdGlhbGl6ZSB0aGUgZ2xvYmFscyBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgLy8gdGltZSB0aGlzIGNvbXBvbmVudCB0eXBlIGhhcyBiZWVuIG1vdW50ZWRcbiAgICAgIGlmICghd2luKSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgICAgZG9jID0gZG9jdW1lbnQ7XG4gICAgICAgIGRvY0VsID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgZG9jQm9keSA9IGRvYy5ib2R5O1xuICAgICAgICB3aW5IZWlnaHQgPSB3aW4uaW5uZXJIZWlnaHQgfHwgZG9jRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICBNID0gd2luZG93Lk1vZGVybml6cjsgLy8gTm8gU3RpY2t5IG9uIGxvd2VyLWVuZCBicm93c2VyIHdoZW4gbm8gTW9kZXJuaXpyXG5cbiAgICAgICAgaWYgKE0gJiYgTS5wcmVmaXhlZCkge1xuICAgICAgICAgIGNhbkVuYWJsZVRyYW5zZm9ybXMgPSBNLmNzc3RyYW5zZm9ybXMzZDtcbiAgICAgICAgICBUUkFOU0ZPUk1fUFJPUCA9IE0ucHJlZml4ZWQoJ3RyYW5zZm9ybScpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHdoZW4gbW91bnQsIHRoZSBzY3JvbGxUb3AgaXMgbm90IG5lY2Vzc2FyeSBvbiB0aGUgdG9wXG5cblxuICAgICAgdGhpcy5zY3JvbGxUb3AgPSBkb2NCb2R5LnNjcm9sbFRvcCArIGRvY0VsLnNjcm9sbFRvcDtcblxuICAgICAgaWYgKHRoaXMucHJvcHMuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBhY3RpdmF0ZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5pdGlhbERpbWVuc2lvbigpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgfSAvLyBiaW5kIHRoZSBsaXN0ZW5lcnMgcmVnYXJkbGVzcyBpZiBpbml0aWFsbHkgZW5hYmxlZCAtIGFsbG93cyB0aGUgY29tcG9uZW50IHRvIHRvZ2dsZSBzdGlja3kgZnVuY3Rpb25hbGl0eVxuXG5cbiAgICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBbc3Vic2NyaWJlKCdzY3JvbGxTdGFydCcsIHRoaXMuaGFuZGxlU2Nyb2xsU3RhcnQuYmluZCh0aGlzKSwge1xuICAgICAgICB1c2VSQUY6IHRydWVcbiAgICAgIH0pLCBzdWJzY3JpYmUoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLmJpbmQodGhpcyksIHtcbiAgICAgICAgdXNlUkFGOiB0cnVlLFxuICAgICAgICBlbmFibGVTY3JvbGxJbmZvOiB0cnVlXG4gICAgICB9KSwgc3Vic2NyaWJlKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZS5iaW5kKHRoaXMpLCB7XG4gICAgICAgIGVuYWJsZVJlc2l6ZUluZm86IHRydWVcbiAgICAgIH0pXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNsYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zbGF0ZShzdHlsZSwgcG9zKSB7XG4gICAgICB2YXIgZW5hYmxlVHJhbnNmb3JtcyA9IGNhbkVuYWJsZVRyYW5zZm9ybXMgJiYgdGhpcy5wcm9wcy5lbmFibGVUcmFuc2Zvcm1zO1xuXG4gICAgICBpZiAoZW5hYmxlVHJhbnNmb3JtcyAmJiB0aGlzLnN0YXRlLmFjdGl2YXRlZCkge1xuICAgICAgICBzdHlsZVtUUkFOU0ZPUk1fUFJPUF0gPSAndHJhbnNsYXRlM2QoMCwnICsgTWF0aC5yb3VuZChwb3MpICsgJ3B4LDApJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLnRvcCA9IHBvcyArICdweCc7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNob3VsZENvbXBvbmVudFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgIHJldHVybiAhdGhpcy5wcm9wcy5zaG91bGRGcmVlemUoKSAmJiAhKHNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpICYmIHNoYWxsb3dFcXVhbCh0aGlzLnN0YXRlLCBuZXh0U3RhdGUpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfY2xhc3NOYW1lcyxcbiAgICAgICAgICBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAvLyBUT0RPLCBcIm92ZXJmbG93OiBhdXRvXCIgcHJldmVudHMgY29sbGFwc2UsIG5lZWQgYSBnb29kIHdheSB0byBnZXQgY2hpbGRyZW4gaGVpZ2h0XG4gICAgICB2YXIgaW5uZXJTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246IHRoaXMuc3RhdGUuc3RhdHVzID09PSBTVEFUVVNfRklYRUQgPyAnZml4ZWQnIDogJ3JlbGF0aXZlJyxcbiAgICAgICAgdG9wOiB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gU1RBVFVTX0ZJWEVEID8gJzBweCcgOiAnJyxcbiAgICAgICAgekluZGV4OiB0aGlzLnByb3BzLmlubmVyWlxuICAgICAgfTtcbiAgICAgIHZhciBvdXRlclN0eWxlID0ge307IC8vIGFsd2F5cyB1c2UgdHJhbnNsYXRlM2QgdG8gZW5oYW5jZSB0aGUgcGVyZm9ybWFuY2VcblxuICAgICAgdGhpcy50cmFuc2xhdGUoaW5uZXJTdHlsZSwgdGhpcy5zdGF0ZS5wb3MpO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgIT09IFNUQVRVU19PUklHSU5BTCkge1xuICAgICAgICBpbm5lclN0eWxlLndpZHRoID0gdGhpcy5zdGF0ZS53aWR0aCArICdweCc7XG4gICAgICAgIG91dGVyU3R5bGUuaGVpZ2h0ID0gdGhpcy5zdGF0ZS5oZWlnaHQgKyAncHgnO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0ZXJDbGFzc2VzID0gY2xhc3NOYW1lcygnc3RpY2t5LW91dGVyLXdyYXBwZXInLCB0aGlzLnByb3BzLmNsYXNzTmFtZSwgKF9jbGFzc05hbWVzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgdGhpcy5wcm9wcy5hY3RpdmVDbGFzcywgdGhpcy5zdGF0ZS5zdGF0dXMgPT09IFNUQVRVU19GSVhFRCksIF9kZWZpbmVQcm9wZXJ0eShfY2xhc3NOYW1lcywgdGhpcy5wcm9wcy5yZWxlYXNlZENsYXNzLCB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gU1RBVFVTX1JFTEVBU0VEKSwgX2NsYXNzTmFtZXMpKTtcbiAgICAgIHZhciBpbm5lckNsYXNzZXMgPSBjbGFzc05hbWVzKCdzdGlja3ktaW5uZXItd3JhcHBlcicsIHRoaXMucHJvcHMuaW5uZXJDbGFzcywgX2RlZmluZVByb3BlcnR5KHt9LCB0aGlzLnByb3BzLmlubmVyQWN0aXZlQ2xhc3MsIHRoaXMuc3RhdGUuc3RhdHVzID09PSBTVEFUVVNfRklYRUQpKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihvdXRlcikge1xuICAgICAgICAgIF90aGlzMy5vdXRlckVsZW1lbnQgPSBvdXRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NOYW1lOiBvdXRlckNsYXNzZXMsXG4gICAgICAgIHN0eWxlOiBvdXRlclN0eWxlXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKGlubmVyKSB7XG4gICAgICAgICAgX3RoaXMzLmlubmVyRWxlbWVudCA9IGlubmVyO1xuICAgICAgICB9LFxuICAgICAgICBjbGFzc05hbWU6IGlubmVyQ2xhc3NlcyxcbiAgICAgICAgc3R5bGU6IGlubmVyU3R5bGVcbiAgICAgIH0sIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHtcbiAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXRlLnN0YXR1c1xuICAgICAgfSkgOiBjaGlsZHJlbikpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdGlja3k7XG59KENvbXBvbmVudCk7XG5cblN0aWNreS5kaXNwbGF5TmFtZSA9ICdTdGlja3knO1xuU3RpY2t5LmRlZmF1bHRQcm9wcyA9IHtcbiAgc2hvdWxkRnJlZXplOiBmdW5jdGlvbiBzaG91bGRGcmVlemUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBlbmFibGVkOiB0cnVlLFxuICB0b3A6IDAsXG4gIGJvdHRvbUJvdW5kYXJ5OiAwLFxuICBlbmFibGVUcmFuc2Zvcm1zOiB0cnVlLFxuICBhY3RpdmVDbGFzczogJ2FjdGl2ZScsXG4gIHJlbGVhc2VkQ2xhc3M6ICdyZWxlYXNlZCcsXG4gIG9uU3RhdGVDaGFuZ2U6IG51bGwsXG4gIGlubmVyQ2xhc3M6ICcnLFxuICBpbm5lckFjdGl2ZUNsYXNzOiAnJ1xufTtcbi8qKlxuICogQHBhcmFtIHtCb29sfSBlbmFibGVkIEEgc3dpdGNoIHRvIGVuYWJsZSBvciBkaXNhYmxlIFN0aWNreS5cbiAqIEBwYXJhbSB7U3RyaW5nL051bWJlcn0gdG9wIEEgdG9wIG9mZnNldCBweCBmb3IgU3RpY2t5LiBDb3VsZCBiZSBhIHNlbGVjdG9yIHJlcHJlc2VudGluZyBhIG5vZGVcbiAqICAgICAgICB3aG9zZSBoZWlnaHQgc2hvdWxkIHNlcnZlIGFzIHRoZSB0b3Agb2Zmc2V0LlxuICogQHBhcmFtIHtTdHJpbmcvTnVtYmVyfSBib3R0b21Cb3VuZGFyeSBBIGJvdHRvbSBib3VuZGFyeSBweCBvbiBkb2N1bWVudCB3aGVyZSBTdGlja3kgd2lsbCBzdG9wLlxuICogICAgICAgIENvdWxkIGJlIGEgc2VsZWN0b3IgcmVwcmVzZW50aW5nIGEgbm9kZSB3aG9zZSBib3R0b20gc2hvdWxkIHNlcnZlIGFzIHRoZSBib3R0b20gYm91ZGFyeS5cbiAqL1xuXG5TdGlja3kucHJvcFR5cGVzID0ge1xuICBlbmFibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgdG9wOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIGJvdHRvbUJvdW5kYXJ5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCAvLyBUT0RPLCBtYXkgcmVtb3ZlXG4gIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgZW5hYmxlVHJhbnNmb3JtczogUHJvcFR5cGVzLmJvb2wsXG4gIGFjdGl2ZUNsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICByZWxlYXNlZENsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBpbm5lckNsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBpbm5lckFjdGl2ZUNsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG9uU3RhdGVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICBzaG91bGRGcmVlemU6IFByb3BUeXBlcy5mdW5jLFxuICBpbm5lclo6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5udW1iZXJdKVxufTtcblN0aWNreS5TVEFUVVNfT1JJR0lOQUwgPSBTVEFUVVNfT1JJR0lOQUw7XG5TdGlja3kuU1RBVFVTX1JFTEVBU0VEID0gU1RBVFVTX1JFTEVBU0VEO1xuU3RpY2t5LlNUQVRVU19GSVhFRCA9IFNUQVRVU19GSVhFRDtcbmV4cG9ydCBkZWZhdWx0IFN0aWNreTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-stickynode/dist/es/Sticky.js\n");

/***/ })

};
;